### HTTP和HTTPS

HTTP 超文本传输协议 （位于应用层） 通常用于客户浏览器端和网站服务器端的通信，他们之间的传输是明文传输的，因此http是不安全的，如果我们传输一些密码等信息很有可能被窃取。
特点是：
简单快速，灵活允许传输多种类型的数据，
无连接，每次连接只处理一个请求，处理完毕哭护短收到应答就断开链接 
无状态，协议无法根据之前的状态进行本次的请求处理（无法记住上一次的状态）

因为http不够安全，所以我们就需要加固http，将其升级，以为我们是通过http将数据发送到tcp然后再经过一系列传输到服务器端，为了保证数据的安全性和不影响其他地方，所以我们就在http到tcp之间增加一个安全层，用来对数据的加密和解密。
最早的加密方式使用的是对称加密：
   首先客户端先向服务端发送一个加密套件列表（就类似一个密码本里面有很多加密方式）和一个随机数列A 
   服务器从加密套件列表中获取一个加密套件，并且将加密套件和生成的一个随机数列B发送给客户端，客户端拿到这个随机数B和之前的随机数列A 合成在一起通过获取的加密套件对这个合成数列进行加密解密，服务端此时获取了同样的随机数A和B还有加密套件，同样能生成相同的密钥对数据进行加密解密，服务端和客户端就用这个密钥对数据加密解密传输数据了。
   缺点：传输加密套件和随机数列AB这个过程是明文传输的黑客还是有机会获取这个密钥。
非对称加密：
   首先客户端先向服务端发送一个加密套件列表，服务端选取加密套件同时生成一个公钥和一个私钥，服务器将公钥发送给客户端，客户端用这个公钥对数据进行加密，发送给服务端，服务端将加密数据用私钥解密。（在这个过程中黑客虽然能获取到公钥，但是无法获取到私钥，对数据进行解密，所以客户端发送给服务器端的数据是安全的）
   缺点：虽然客户端发送给服务端的数据是安全的，但是服务端发送给客户端的数据用私钥加密黑客是能用公钥进行解密的，所以服务器端发送给客户端的数据是不安全的。
非对称加密和对程加密组合：
   首先客户端先向服务端发送对程加密套件列表，非对程加密套件列表和一个随机数A ,服务端选取对程加密套件和非对程加密套件，同时生成一个随机数B和一对公钥私钥，将加密套件和非对程加密套件随机数B和公钥发送给客户端，客户端生成随机数C，用公钥加密C将数据发送给服务端，服务端获取到数据后用私钥解密获取到随机数C这样服务端和客户端都有了随机数ABC 和对称加密套件，这样两边都能生成一个相同的私钥和密钥对数据进行加密解密，因为这个过程中随机数C是通过非对程加密的，只有服务端才有私钥对数据进行解密获取C,所以C是安全的，这样对程套件生成的密钥也就是安全的。
数字证书：
   通过非对称加密和对程加密组合，我们现在能将数据安全的传输了，但是还有一个问题就是我们如何确定我们和我们建立联系的服务端就是我们想要访问的服务端呢，有可能黑客DNS劫持，对伪造了服务端的IP和我们通信我们并不知道，因此我们需要验证服务端就是我们想要联系的服务端，着我们就需要用到数字证书，数字证书就类似房产局，比如我们买房的时候房产局需要验证我们的身份证号银行流水什么的东西，验证完成以后就给我们颁发这个房产证，房产证就能证明这个房子是我们的里面包含了我的身份信息房屋信息什么的，我们就能通过这个房产证证明自己是房子的主人，这个例子中的房产局就是CA 房产证就是数字证书。服务器向CA权威机构申请了证书，证书还包含了公钥，服务器向客户端之前是发送公钥，现在是替换成数字证书了。
数字证书验证过程：
   首先服务器端向CA发送自己的各种信息，然后CA会通过线上线下的各种方式，去验证这些信息的真实性。验证完成以后就会用hash的方式将这些信息计算生成信息摘要，然后将信息摘要在用CA的私钥进行加密生成数字签名，然后CA就会给服务器端签发数字证书（里面包含了服务器和CA的各种信息）和数字签名。
   服务器向客户端发送数字证书，客户端就拿到数字证书进行验证，首先会将数字证书里面的各种信息用CA同样的hash方式进行计算生成信息摘要，然后再将数字签名用CA的公钥进行解密生成信息摘要，将两段信息摘要进行对比看看是否一样来判断数字证书的真实性，依次来判断服务器的真实性。
如何判断CA的真实性
   CA分为中间CA和根CA，根CA给这些中间CA证明，中间CA又可以给其他中间CA认证，最后生成一个CA链，服务器是可以拿到这个CA链的，通过CA链可以找到根CA，根CA是内置在操作系统中的，而这些根CA就由最权威的机构认证，只有几个而已。通过此我们就可以拿到CA的公钥。



### UDP和TCP
UDP和TCP都是位于传输层的协议
TCP是一种面向字节流的通信协议，他会将应用层的报文当作一段无结构的字节流，将其分解为多个TCP报文传输，最后到底目的地以后进行重新装配。UDP是一种面向报文的协议，他会将应用层发送过来的数据报文加上首部以后直接发送。
TCP是面向连接的协议，建立连接需要三次握手，断开连接需要四次挥手。UDP是无连接，直接将数据发送到网络层
TCP是更可靠的传输数据，传输通过流量控制编号和计时器等来确定数据的安全可靠不丢失。UDP是尽可能的将数据发送过去，他对发送的数据不负任何责任不可靠。
TCP是全双工的通信。UDP是可以一对一，一对多，多对一，多对多的传输。

OSI 七层模型

开放式通信系统互联参考模型
应用层 http  DNS 应用程序之间的交互规则
表示层     压缩数据加密数据
会话层     建立管理通信
传输层 TCP UDP  管理数据的传输
网络层 IP       选择合适的节点确保数据的传送
数据链路层       数据需要在链路中传输
物理层          确定机器特性

TCP/IP协议
五层结构：
应用层
传输层  
网络层
数据链路层
物理层
四层结构：
应用层
传输层
网络层
网络接口层

TCP 三次握手（三次握手的目的主要是为了判断客户端和服务端的接受和发送能力是否ok）
第一次握手客户端向服务端发送一个SYN报文，并且指明客户端的初始序列号ISN 此时客户端的状态为SYN-send状态 （此时服务端接受到这些数据后就服务端就知道客户端的发送能力和服务端的接受能力是ok的）
第二次握手服务端接受到客户端的SYN以后，也会用自己的SYN报文作为应答，并且也会生成一个服务端的初始化序列号ISN 并且将客户端的ISN加1作为ACK报文发送给客户端，此时服务端处于SNY-RCVD。（此时客户端接受到这些数据后客户端就知道自己的发送能力和接受能力是ok的服务端的发送能力是ok的，但是此时服务端不知道自己的发送能力是不是OK的）
第三次握手客户端将服务端的初始化序列号ISN加1 的值作为ACK报文发送个服务端，此时服务端就知道自己的发送能力是ok的。（客户端和服务端处于establised）
问题1. ISN初始化序列号是不是固定的？（不是固定的，是随机的，如果是固定的那么黑客很容易去猜接下来的ACK报文）
问题2. 什么是半连接队列？（服务端第一次接受客户端的SYN以后，客户端此时处于SYN-rcvd状态，还没完全建立连接服务器会把此时的请求放在一个队列中，这个队列就是半连接队列）
问题3. 三次握手可以携带数据吗？（前两次不可以，第三次可以，因为如果前两次传输数据的话，黑客在传输过程中传输大量的数据并且多次重复的发送，不管服务器端的接受能力如何就是发，这就导致服务端需要花费很多时间和空间来接受这些报文）

四次挥手，断开连接
第一次挥手，如果是客户端主动发起的断开连接，首先客户端会向服务端发送FIN报文同时还有一个初始的一个序列号。（客户端变沉FIN-waiting 状态）
第二次挥手，服务端接受到FIN报文以后，会发送一个ACK报文，且把客户端的序列值加一作为ACK的序列号发送给客户端。（此时客户端变成close_waiting状态）
第三次挥手 服务端要断开连接，他向客户端发送FIN报文和指定的初始序列号（服务端变沉last_ACK状态）
第四次挥手 客户端接受到FIN报文，会想服务端发送一个ACK报文，且将服务端发送的序列号加一作为ACK报文的序列号。此时服务端收到以后状态变成close状态，客户端是一个time-waiting 的状态太会过一段时间才变成close状态，因为客户端需要等待服务端不在发送FIN报文，确保自己的ACK报文被服务端接受到，才会将状态变成close，如果服务端没有接受到是会在发送FIN报文的，这个等待时间最少是一个ACK报文往返的时间，还有一个原因是要等待服务端是否将所有的数据发送完毕。

为什么要四次挥手，挥手时服务端不能同时将ACK报文和FIN报文一块发送给客户端，因为服务端在接受到断开连接的FIN 报文以后可能还有数据需要发送到客户端，所以他会先发送一个应答的ACK报文给客户端，我们收到你的请求了，我现在把我这里的数据传输完以后我会在发送FIN报文来断开连接

TCP的可靠性
序列号和确认应答号（ISN ACK）：
我们通过确认应答ACK来判断是否对方是否能收到我们的消息，比如客户端发给服务端SYN报文的时候，为了向客户端表示服务端收到了，服务端会想客户端发送一个ACK应答，这个ACK应答是客户端的初始序列号ISN加一得到的。如果客户端没有收到相应的ACK应答，客户端会认为自己发送的数据没有到服务端就会重发，因为发送失败的原因可能是服务端发送的数据失败了，这就会导致服务器端收到重复的数据，浪费网络资源，因此这里就用到ISN序列号，来代表字节数，比如客户端向服务端发送的是1到1000的字节数，服务端收到以后 ，会保存这个字节数，如果客户端发送的数据小于这个值是会直接抛弃掉的。
TCP超时重传机制时间如何判定？
每次发包时的往返时机加上网络波动值。
如果多次重发没有应答，时间会按指数增加，但是不会无限增加会有一个最终值，最后直接关闭连接。
TCP滑动窗口，流量控制
TCP以一个TCP字节段为单位，每次发送一个段就需要ACK应答一次才能发送下一次段，如果往返时间过长很效率很低，所以引入滑动窗口的概念，即使没有收到ACK应答也可以继续给服务端发送数据，不需要一直等待ACK的应答，就是类似出现缓冲区。比如窗口大小为4000，每个段是1000，当客户端发送一个段给服务端，服务端接受到后计算自己这里还能接受3000字节数据，就给客户端发个ACK，里面就包含了还能再发3000字节的数据，客户端就继续发送数据，直到服务端处理不了这么多消息，就会给客户端发送ACK代表自己接受不了数据了，客户端就会停止发送数据，过一段时间后会发一个窗口探测的包，看看滑动窗口是否更新是否能在发数据。
TCP拥塞控制
有了滑动窗口的控制，发送端不在以一段一段为单位，而是以一个窗口为单位发送，但是如果刚开始就发送很大的数据网络可能就承受不住。
如果网络波动导致服务器接受不了这么多数据包，但是客户端有一只以为数据包丢失，继续重传，服务端就一直丢弃新包，最后导致网络心性能下降，网络瘫痪，我们就给客户端也设置一个拥塞窗口，来控制发送段的发送的数据大小，发送窗口就取拥塞窗口和滑动窗口的最小值。
运用慢算法和拥塞避免算法结合来控制拥塞窗口的大小
一开始防治发送的数据量过大运用慢算法，从窗口大小为1 开始发送，然后按指数的上涨，直到碰到满启动的阀值，这个阀值为发送窗口的一半大小，到了阀值以后开始该用拥塞避免算法每次给拥塞窗口加1，直到出现网络拥塞，将拥塞窗口重新设置为一，阀值设置为出现网络拥塞时的发送窗口的一半大小，然后重复慢运算和拥塞控制运算。
超时重传和快重传： 超时没有收到ACK报文就会重新进入慢启动阶段，3次收到服务端数据丢失的信号也会重传，
快恢复：三次收到丢失信号，判断不是网络拥塞时，则不会进入慢启动而是进入拥塞避免算法加一。

### CDN 内容分发网络
CDN根据用户的位置分配最近的资源。
运用CDN 放我们访问一个站点时，浏览器对域名解析，DNS 返回一个别名记录指向全局负载均衡，本地DNS就会访问这个负载均衡系统，系统就会根据地理位置和节点压力，给用户返回一个最合适的节点，用户就能狗访问DNS的缓存代理。

### HTTP 1.0 HTTP1.1 HTTP 2.0
HTTP 超文本传输协议，主要用于客户端和服务端连接通信。
http1.0 之前http只用于学术交流只能发送get请求获取html文件 
网络的发展和需求使人们开发了 http1.0 ，原来只能满足HTML文件的下载传输，现在需要满足js图片css等文件下载传输。为了满足这个需求 HTTP1.0 引入了请求头和响应头，请求头会告诉服务器我想接受什么类型的文件压缩格式是什么样的，语言和编码是什么样的（accept,accept-encoding -charset -language），服务器就根据响应的请求头返回响应的数据，如果不能返回也会在响应的响应头里面标明返回的格式。
除此之外还引入了状态码和缓存机制（用户代理）等
HTTP1.1，虽然HTTP已经满足各种文件的传输了但是依旧有缺陷，首先是HTTP1.0 都是通过TCP三次握手建立连接的，传输完数据以后就断开连接，然后有重新握手建立连接断开连接，最开始页面简单传输的数据较少，也不太影响，但是之后页面丰富以后，页面要请求的内容就多起来了，所以这个连接和断开的操作是比较消耗时间的，于是HTTP1.1增加了持久连接的方法，即只握手一次建立连接以后就一直保持连接状态，直到浏览器或者服务器明确断开连接。浏览器目前最多建立6个长连接。除此之外请求头还增加了host，用来表示当前域名地址，还有更多的请求方法（put delete）和cookie,管线化。引入chunk transfer（块传输的方式），因为http1.0 都是有一个Content-Length,来代表接受数据的大小，但是1.1以后很多数据都是动态的，不是一个固定的值，于是服务端就把数据切成块发送给客户端，每个块都会有上个数据块的长度，最后一个用0长度的数据块表示结束。
HTTP2.0 虽然1.1已经通过长连接大大增加了资源加载的速率，但是带宽利用率不足，导致带宽利用率不足的主要原因是1. 慢启动，为了避免网络拥塞的一种算法策略 2. 多个TCP连接会相互竞争带宽（导致各个TCP都会减少数据的传输速率），有些tcp传输的是比较重要的文件比如首频的信息，但是因为TCP并不知道那些数据是重要的，会将其当作普通数据加载，影响关键资源的加载。3. 队头阻塞，1.1是持久连接公用一个TCP管道传输，但是管道中一个时间端只能有一个请求，等这个请求结束，才能开始下一个，如果一个请求被阻塞会导致后面的请求都阻塞，这是非常浪费的。为了解决上面的问题http2.0，首先是一个域名下只有一个TCP连接这样就避免了，慢启动和多个TCP竞争带宽。然后增加了多路复用的机制，在http的下层增加了一个二进制分帧层，浏览器准备好请求数据将请求头请求行请求体等信息发送到二进制分帧层，二进制分帧层将这些数据处理成一帧一帧的形式，并且相同的请求是放上相同的的id，然后一起发送给服务端，服务端接受到以后将这些数据通过相同的id拼凑成请求体请求头和请求行，然后响应相应的响应行响应头和响应体，发送到二进制分帧层，然后将这些数据处理成帧的形式发送给浏览器浏览器在根据id拼凑成响应行响应头和响应体。这样就避免了一个队头阻塞。基于多路复用我们还能实现设置请求的优先级，我们可以在请求体上标上优先级，除此之外还有服务器推送比如我们请求了一个html,这个html上的图片资源和css资源也会主动推送给客户端。压缩头部，就是在客户端和服务端之间建立一个hash表，将用到的字段存放在这个表中，如果接下来的请求用相同的字段我们直接把索引发过去（比如1，2，3）服务端接收到以后直接通过索引表查询即可。






### URL 到页面发生了什么
先从进程的角度分析从输入url到页面发生了什么？
当用户输入url的时候，浏览器进程接收到用户输入的url请求，将它发送给网络进程，
然后再网络进程中真正发起url请求，服务器接受到请求头等数据后
给客户端反会相应的响应头，网络进程接收到这些响应头数据后将数据发送给浏览器进程
浏览器进程接收到以后给渲染进程发送消息“提交导航”
渲染进程接收到信息以后和就准备开始和网络进程建立数据管道接收HTML等文件数据
然后渲染进程准备完毕，想浏览器进程发送消息我这边已经准备好就收数据和解析数据了。
浏览器进程收到消息以后就开始吧之前的旧文件删除，更新浏览器进程中的页面状态。

1. 用户输入
首先如果原来页面中定义了beforeunload事件，会先终止导航判断用户是否需要离开这个页面。
然后浏览器地址栏会判断输入的是正常的url还是字符串什么的，如果是字符串什么的就会拼接上响应的浏览器的默认搜索引擎，来合成新的url。
2. url 请求过程
拿到url以后浏览器进程会通过进程通行IPC把URL发送给网络进程，在网络进程中发起url请求，
首先网络进程会查找本地缓存是否缓存了该资源（强缓存和协商缓存），如果没有命中缓存，就进入网络请求流程。首先请求的第一步是进行DNS解析，获取服务器IP地址。（DNS解析）如果是HTTPS协议，还要进行TLS连接保证数据的安全。（TLS算法和数字证书验证）。然后就是利用IP地址和服务器建立TCP连接（三次握手和TCP的可靠性），连接建立后网络进程就会发送请求头请求行（请求头里面有哪些值分别代表什么意思）等信息发送给服务端，服务端接受到数据以后就会返回相应的响应头。
网络进程接收到服务端的响应头以后就开始解析这个响应头，如果解析发现这个状态码是301或者302 就需要重定向，我们就从响应头location里面获取响应的重定向的地址，然后又开始一次之前的轮回，直到返回的响应头是200相关的状态码，解析完以后就分配一个渲染进程，浏览器进程就告诉渲染进程准备好和网络进程传输数据数据管道，然后渲染进程就去准备和网络进程传输的数据管道，等数据传输完毕后，渲染进程会给浏览器进程发送一个确认的消息表示我的数据接受完毕，浏览器进程此时才会去将页面原来的旧文件给删除掉。
同时渲染进程也开始进入渲染阶段。（渲染阶段标签图片再转动，完成渲染才会loading效果才会消失）

3. 渲染过程
我们的页面是有HTML CSS JS 组成的，我们接受到这几个文件以后就开始解析

首先是构建DOM树：
因为浏览器无法直接理解和使用HTML，所以需要将HTML通过HTML解析器将之转换成浏览器能够理解的DOM树，

样式计算
通过上一步我们获取了DOM树，然后我们每个DOM节点的样式
 * 我们的样式来源主要是三个一个是link外链引入的，一个是 style 标签包裹的 一个是行内样式，这些也是浏览器这些纯文本的样式，当渲染引擎接收到以后会将其转换成浏览器可以理解的stylesheets
 * 然后会标准化一些属性，比如stylesheets中有些特殊的属性值比如em 或者blue 等颜色属性，渲染引擎会将这些属性比如em转换为px blue转换为rgb的格式
 * 最后是计算每个节点的具体样式 我们已经知道的各个节点的单独样式，但是样式是遵守继承和层叠的规则，所以需要重新计算整理输出每个样式的单独样式（最终样式Computed）

 布局阶段
 现在我们有了DOM树和DOM树中元素的样式，我们就可以对这些DOM进行一个布局，计算这些元素的几何位置。
 创建布局树就是把不可见元素都剔除掉（比如display:none 或者一些不带变几何元素的dom，比如script  head ）然后计算生成一个布局树

 分层(layer)
 我们的页面不是一个二维的一个页面而是三维立体的，渲染引擎还需要为特定的一些节点生成专用的图层，并生成一个对应的图层树。
 特定节点：
 设置z-index部位auto; position:fixed/sticky ;  opactiy ；filter(滤镜效果)等属性
 需要裁剪的地方，比如一段文本超出隐藏，也会为文本单独提升一个层。

 图册绘制
 生成的图册我们需要给图层做绘制，绘制过程就是渲染引擎会讲图层绘制的过程分成一个个小指令列表，比如给图层背景画成绿色然后再中间画圆，然后再画上换三角形等等，

 栅格化操作
 有了指令列表以后，渲染引擎中的合成线程就会开始绘制。因为我们页面可能是一个长列表，我们视窗口不需要展示那么多，所以我们会优先绘制视窗口附近的图层，我们会讲页面分成很多很多的图块，在视窗附近的图块就会优先绘制正位图，生成位图的操作是由栅格化来执行的,这个栅格化的过程会使用GPU加速来完成，会进入GPU进程中生成位图

 合成和显示
 图块被栅格化以后，会给浏览器进程发送一个命令表示栅格化完成，浏览器进程中会根据命令使用viz组件将页面内容绘制到内存中，然后再将内存显示在屏幕上。


### 进程和线程
线程是CPU调度的最小单位，进程是资源分配的最小单位。（类比进程就是火车，线程就是车厢）
什么是并行处理： 比如我们计算 a = 1+2 ;b =1*2;c=2/1;最后讲结果显示出来，如果是单线程的话就需要4步分别将结果计算出来，最后再显示出来，但是如果是多线程的话，我们只需要两步，我们利用多线程并行计算三个结果，然后再显示出来即可。线程是由进程来启动过和管理的。
一个进程就是一个程序的运行实例，当我们启动一个程序的时候操作系统会为我们的程序开辟一块内存空间用来存放程序运行的代码，可用的数据和一天主线程，这个运行环境我们就吧他称之为进程。
四个特点:
任意线程执行出错，进程就会崩溃
线程之间共享进程的数据
当进程关闭，进程占用的内存都会被回收
进程之间的内容相互隔离

浏览器多进程架构：
浏览器进程：页面交互等
渲染进程：渲染dom和数据
GPU进程： 做动画
网络进程：下载网络资源
插件进程：控制插件，将插件隔离，防止页面崩溃

### DNS解析
DNS 域名系统 解析域名转换成相应IP地址的服务器。
按层级划分：本地域名服务器   根域名服务器  顶级域名服务器  权限域名服务器
在域名解析的过程中可以使用缓存保存域名和IP映射，有两种缓存凡事一个好似浏览器缓存，一个是自己手动缓存到host文件中
查询方式：递归查询一路问下去直到问到为止在原路返回；迭代查询，问一次回来答复一次；
查询过程：
首先检查浏览器的DNS缓存和操作系统的缓存，没有的话，主机将域名发送给本地域名服务器开始递归查询，然后本地服务器会开始迭代查询先去根域名服务器查找，根域名服务器返回顶级域名服务器地址给本地服务器
本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
本地域名服务器获取到IP地址以后返回给主机同时将IP地址缓存
主机将ip返回给浏览器，浏览器将IP 缓存起来

### 常见的请求头
Accept	能够接受的回应内容类型（Content-Types）
Accept-Charset	能够接受的字符集	
Accept-Encoding	能够接受的编码方式列表
Accept-Language	能够接受的回应内容的自然语言列表
Cache-Control	用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令
Connection	该浏览器想要优先使用的连接类型
Cookie	服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie
Content-Length	以 八位字节数组 （8位的字节）表示的请求体的长度
Host	服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号
If-Match	仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源
If-Modified-Since	允许在对应的内容未被修改的情况下返回304未修改
If-None-Match	允许在对应的内容未被修改的情况下返回304未修改
Range	仅请求某个实体的一部分
User-Agent	浏览器的浏览器身份标识字符串
Origin	发起一个针对 跨来源资源共享 的请求

### GET 和 POST 


### HTTP 常见状态码


### 强缓存  协商缓存

### 跨域操作
https://segmentfault.com/a/1190000011145364
https://www.ruanyifeng.com/blog/2016/04/cors.html
### promise
### 遍历器