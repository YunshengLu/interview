reactDom.render(<p>hello worlrd</p>,root)
这个语句 react 进过三部分最后渲染在页面
产生更新 （调度）
决定更新什么组件 （协调）
将更新的组件渲染都页面 （渲染）

计算能力 和 网络延迟 是制约快速相响应的主要问题
计算能力 1000ms / 60hz = 16ms 一帧 一帧要做脚本执行 页面布局 页面绘制，如果一帧内没做完就会卡顿
解决方法节流和防抖，react 使用的是异步更新 react 和浏览器做了一个约定，浏览器将自己一帧中的时间预留给 react， react 利用这部分预留的时间来完成自己的工作，如果某个工作要求的时间特别长，超出了预留时间，react 会中断自己的工作，并将控制权交给浏览器，等待下一帧预留时间到来再去执行，这样浏览器在没一帧都有时间去做样式布局和样式绘制，减少掉帧的可能性。

老的 react 架构主要分为两部分
决定渲染什么组件 reconciler(协调器) （diff 算法就在其中计算）
将组件渲染到视图中 renderer(渲染器)

例子:老架构： 一段代码生成一个按钮和三个 li 点击按钮三个 li 数字 123 变成 246 每次 ×2 ，老架构是 reconciler(协调器) 发现 state 改变 1 变成 2，于是改变第一个 li,渲染器就去渲染，然后再发现第二个 listate 也改变，然后再去改变第一二 li,渲染器去渲染，以此类推，最终渲染完成的，因为是同步的操作，所以不会有那种 123=》223 这种，而是用户感知就是 123=》246。
老版的架构如果做异步可中断更新，就会变成 123=》223 这种。

新架构分为三部分:
调度更新 scheduler (调度器)
决定更新什么 reconciler(协调器)
将组件更新到视图中 renderer(渲染器)
例子:新架构：点击按钮 state 值增加，首先调度器接受到 state 更新，然后查看是否有更高优先级的任务，没有就将更新交给协调器，协调器接受更新，进行 dom diff,创建虚拟 dom 树，需要更改 dom 就被打上 update 标记，将打了标记的虚拟 dom 树交给渲染器更新，渲染器更具虚拟 dom 树被被标记的 update 更新 dom
